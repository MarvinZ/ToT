import { Injectable, EventEmitter, Output } from '@angular/core';
import { Http } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/map';
import 'rxjs/add/observable/merge';
import { LocaleService } from './locale.service';
import { IntlAPI } from './intl-api';
import { TranslationConfig } from '../models/translation/translation-config';
import { Config } from '../models/translation/config';
import { LoadingMode } from '../models/translation/loading-mode';
import { ServiceState } from '../models/translation/service-state';
/**
 * Manages the translation data.
 */
export var TranslationService = (function () {
    /**
     * @param {?} locale
     * @param {?} http
     */
    function TranslationService(locale, http) {
        var _this = this;
        this.locale = locale;
        this.http = http;
        this.translationChanged = new EventEmitter(true);
        this._configuration = new Config();
        this.translationData = {};
        this.serviceState = ServiceState.isWaiting;
        // When the language changes, loads translation data.
        this.locale.loadTranslation.subscribe(function () { _this.loadTranslation(); });
    }
    Object.defineProperty(TranslationService.prototype, "configuration", {
        /**
         * @return {?}
         */
        get: function () {
            return this._configuration;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Configure the service in the application root module or bootstrap component.
     * @return {?}
     */
    TranslationService.prototype.AddConfiguration = function () {
        return new TranslationConfig(this);
    };
    /**
     * Call this method after the configuration to initialize the service.
     * @return {?}
     */
    TranslationService.prototype.init = function () {
        if (this.configuration.providers.length > 0) {
            this.loadingMode = LoadingMode.Async;
        }
        else {
            this.translationData = this.configuration.translationData;
            this.loadingMode = LoadingMode.Direct;
        }
        this.loadTranslation();
    };
    /**
     * The language of the translation service is updated when the translation data has been loaded.
     * @return {?}
     */
    TranslationService.prototype.getLanguage = function () {
        return this.language;
    };
    /**
     * @param {?} key
     * @param {?=} args
     * @param {?=} lang
     * @return {?}
     */
    TranslationService.prototype.translate = function (key, args, lang) {
        if (args === void 0) { args = null; }
        if (lang === void 0) { lang = this.language; }
        // I18n plural.
        if (/^\d+\b/.exec(key)) {
            return this.translateI18nPlural(key, args, lang);
        }
        return this.getValue(key, args, lang);
    };
    /**
     * @param {?} key
     * @param {?=} args
     * @param {?=} lang
     * @return {?}
     */
    TranslationService.prototype.translateAsync = function (key, args, lang) {
        var _this = this;
        if (lang === void 0) { lang = this.language; }
        return Observable.create(function (observer) {
            var /** @type {?} */ value = _this.translate(key, args, lang);
            observer.next(value);
            observer.complete();
        });
    };
    /**
     * @param {?} key
     * @param {?} args
     * @param {?} lang
     * @return {?}
     */
    TranslationService.prototype.translateI18nPlural = function (key, args, lang) {
        var /** @type {?} */ keyText = key.replace(/^\d+\b/, "");
        keyText = keyText.trim();
        var /** @type {?} */ keyNumber = parseFloat(key);
        key = key.replace(/^\d+/, this.translateNumber(keyNumber));
        return key.replace(keyText, this.getValue(keyText, args, lang));
    };
    /**
     * @param {?} key
     * @param {?} args
     * @param {?} lang
     * @return {?}
     */
    TranslationService.prototype.getValue = function (key, args, lang) {
        var /** @type {?} */ value;
        if (this.translationData[lang]) {
            var /** @type {?} */ translation = this.translationData[lang];
            // Composed key.
            var /** @type {?} */ keys = key.split(this.configuration.keySeparator);
            do {
                key = keys.shift();
                if (translation[key] && typeof translation[key] === "object") {
                    translation = translation[key];
                }
            } while (keys.length > 0);
            value = translation[key];
        }
        return this.parseValue(key, value, args, lang);
    };
    /**
     * @param {?} keyNumber
     * @return {?}
     */
    TranslationService.prototype.translateNumber = function (keyNumber) {
        if (!isNaN(keyNumber) && IntlAPI.HasNumberFormat()) {
            var /** @type {?} */ localeNumber = new Intl.NumberFormat(this.language).format(keyNumber);
            return localeNumber;
        }
        return keyNumber.toString();
    };
    /**
     * @param {?} key
     * @param {?} value
     * @param {?} args
     * @param {?} lang
     * @return {?}
     */
    TranslationService.prototype.parseValue = function (key, value, args, lang) {
        if (value == null || value == "") {
            return this.handleMissingValue(key, args, lang);
        }
        else if (args) {
            return this.handleArgs(value, args);
        }
        return value;
    };
    /**
     * @param {?} key
     * @param {?} args
     * @param {?} lang
     * @return {?}
     */
    TranslationService.prototype.handleMissingValue = function (key, args, lang) {
        if (this.configuration.missingKey != null) {
            return this.translate(this.configuration.missingKey, args, lang);
        }
        else if (this.configuration.missingValue != null) {
            return this.configuration.missingValue;
        }
        // The same key is returned.
        return key;
    };
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    TranslationService.prototype.handleArgs = function (value, args) {
        var /** @type {?} */ TEMPLATE_REGEXP = /{{\s?([^{}\s]*)\s?}}/g;
        return value.replace(TEMPLATE_REGEXP, function (substring, parsedKey) {
            var /** @type {?} */ replacer = (args[parsedKey]);
            return typeof replacer !== "undefined" ? replacer : substring;
        });
    };
    /**
     * @return {?}
     */
    TranslationService.prototype.loadTranslation = function () {
        var /** @type {?} */ language = !this.configuration.localeAsLanguage
            ? this.locale.getCurrentLanguage()
            : this.locale.getCurrentLanguage()
                + "-"
                + this.locale.getCurrentCountry();
        if (language != null && language != this.language) {
            if (this.loadingMode == LoadingMode.Async) {
                this.getTranslation(language);
            }
            else {
                this.releaseTranslation(language);
            }
        }
    };
    /**
     * @param {?} language
     * @return {?}
     */
    TranslationService.prototype.getTranslation = function (language) {
        var _this = this;
        this.translationData = {};
        this.serviceState = ServiceState.isLoading;
        var /** @type {?} */ observableSequencesOfTranslationData = [];
        for (var _i = 0, _a = this.configuration.providers; _i < _a.length; _i++) {
            var provider = _a[_i];
            var /** @type {?} */ url = provider.prefix;
            if (provider.webAPI) {
                url += language;
            }
            else {
                url += language + "." + provider.dataFormat;
            }
            observableSequencesOfTranslationData.push(this.getTranslationByProvider(url));
        }
        // Merges all the observable sequences into a single observable sequence.
        Observable.merge.apply(Observable, observableSequencesOfTranslationData).subscribe(function (data) {
            _this.addData(data, language);
        }, function (error) {
            console.error("Translation service:", error);
        }, function () {
            _this.releaseTranslation(language);
        });
    };
    /**
     * @param {?} url
     * @return {?}
     */
    TranslationService.prototype.getTranslationByProvider = function (url) {
        return this.http.get(url)
            .map(function (res) { return res.json(); });
    };
    /**
     * @param {?} data
     * @param {?} language
     * @return {?}
     */
    TranslationService.prototype.addData = function (data, language) {
        this.translationData[language] = typeof this.translationData[language] !== "undefined"
            ? this.extend(this.translationData[language], data)
            : data;
    };
    /**
     * @param {...?} args
     * @return {?}
     */
    TranslationService.prototype.extend = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var /** @type {?} */ newObj = {};
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var obj = args_1[_a];
            for (var key in obj) {
                newObj[key] = obj[key];
            }
        }
        return newObj;
    };
    /**
     * @param {?} language
     * @return {?}
     */
    TranslationService.prototype.releaseTranslation = function (language) {
        this.serviceState = ServiceState.isReady;
        this.language = language;
        // Sends an event for the components.
        this.translationChanged.emit(language);
    };
    TranslationService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    TranslationService.ctorParameters = function () { return [
        { type: LocaleService, },
        { type: Http, },
    ]; };
    TranslationService.propDecorators = {
        'translationChanged': [{ type: Output },],
    };
    return TranslationService;
}());
function TranslationService_tsickle_Closure_declarations() {
    /** @type {?} */
    TranslationService.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    TranslationService.ctorParameters;
    /** @type {?} */
    TranslationService.propDecorators;
    /** @type {?} */
    TranslationService.prototype.translationChanged;
    /** @type {?} */
    TranslationService.prototype.serviceState;
    /** @type {?} */
    TranslationService.prototype.loadingMode;
    /** @type {?} */
    TranslationService.prototype._configuration;
    /** @type {?} */
    TranslationService.prototype.language;
    /**
     * The translation data: {language: {key: value}}.
     * @type {?}
     */
    TranslationService.prototype.translationData;
    /** @type {?} */
    TranslationService.prototype.locale;
    /** @type {?} */
    TranslationService.prototype.http;
}
//# sourceMappingURL=translation.service.js.map