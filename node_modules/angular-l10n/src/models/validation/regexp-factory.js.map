{"version":3,"file":"regexp-factory.js","sourceRoot":"","sources":["../../../../src/models/validation/regexp-factory.ts"],"names":[],"mappings":"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","sourcesContent":["import { DecimalCode } from './decimal-code';\n/**\n * @param {?} obj\n * @return {?}\n */\nexport function isPresent(obj: any): boolean {\n    return typeof obj !== \"undefined\" && obj != null;\n}\nexport class RegExpFactory {\n/**\n * Builds the regular expression for a number according to default locale.\n * @param {?} defaultLocale\n * @param {?} digits\n * @return {?}\n */\npublic number(defaultLocale: string, digits: string): RegExp {\n        let /** @type {?} */ minInt: number = 1;\n        let /** @type {?} */ minFraction: number = 0;\n        let /** @type {?} */ maxFraction: number = 3;\n\n        if (isPresent(digits)) {\n            const /** @type {?} */ NUMBER_FORMAT_REGEXP: RegExp = /^(\\d+)?\\.((\\d+)(\\-(\\d+))?)?$/;\n            let /** @type {?} */ parts: RegExpMatchArray = digits.match(NUMBER_FORMAT_REGEXP);\n            if (isPresent(parts[1])) {  // Min integer digits.\n                minInt = parseInt(parts[1]);\n            }\n            if (isPresent(parts[3])) {  // Min fraction digits.\n                minFraction = parseInt(parts[3]);\n            }\n            if (isPresent(parts[5])) {  // Max fraction digits.\n                maxFraction = parseInt(parts[5]);\n            }\n        }\n\n        let /** @type {?} */ decimalCode: DecimalCode = new DecimalCode(defaultLocale);\n\n        let /** @type {?} */ minusSign: string = decimalCode.minusSignCode;\n        let /** @type {?} */ zero: string = decimalCode.numbersCodes[0];\n        let /** @type {?} */ decimalSeparator: string = decimalCode.decimalSeparatorCode;\n        let /** @type {?} */ nine: string = decimalCode.numbersCodes[9];\n\n        // Pattern for 1.2-2 digits: /^-?[0-9]{1,}\\.[0-9]{2,2}$/\n        // Unicode pattern = \"^\\u002d?[\\u0030-\\u0039]{1,}\\\\u002e[\\u0030-\\u0039]{2,2}$\"\n        let /** @type {?} */ pattern: string;\n        if (minFraction > 0 && maxFraction > 0) {\n            pattern = \"^\"\n                + minusSign\n                + \"?[\" + zero + \"-\" + nine\n                + \"]{\" + minInt + \",}\\\\\"\n                + decimalSeparator\n                + \"[\" + zero + \"-\" + nine\n                + \"]{\" + minFraction + \",\" + maxFraction\n                + \"}$\";\n        } else if (minFraction == 0 && maxFraction > 0) {\n            // Decimal separator is optional.\n            pattern = \"^\"\n                + minusSign\n                + \"?[\" + zero + \"-\" + nine\n                + \"]{\" + minInt + \",}\\\\\"\n                + decimalSeparator\n                + \"?[\" + zero + \"-\" + nine\n                + \"]{\" + minFraction + \",\" + maxFraction\n                + \"}$\";\n        } else {\n            // Integer number.\n            pattern = \"^\"\n                + minusSign\n                + \"?[\" + zero + \"-\" + nine\n                + \"]{\" + minInt + \",}$\";\n        }\n        pattern = decimalCode.UnicodeToChar(pattern);\n        let /** @type {?} */ regExp: RegExp = new RegExp(pattern);\n        return regExp;\n    }\n\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}